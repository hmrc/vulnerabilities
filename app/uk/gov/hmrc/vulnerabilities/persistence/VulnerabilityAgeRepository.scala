/*
 * Copyright 2023 HM Revenue & Customs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package uk.gov.hmrc.vulnerabilities.persistence

import cats.implicits._
import org.mongodb.scala.ObservableFuture
import org.mongodb.scala.bson.BsonDocument
import org.mongodb.scala.model.{Aggregates, Accumulators, IndexModel, IndexOptions, Indexes}
import uk.gov.hmrc.mongo.MongoComponent
import uk.gov.hmrc.mongo.MongoUtils.DuplicateKey
import uk.gov.hmrc.mongo.play.json.PlayMongoRepository
import uk.gov.hmrc.vulnerabilities.model.{VulnerabilityAge, Report}

import java.time.Instant
import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}

@Singleton
class VulnerabilityAgeRepository @Inject()(
  mongoComponent: MongoComponent
)(implicit
  ec            : ExecutionContext
) extends PlayMongoRepository(
  collectionName = "vulnerabilityAge",
  mongoComponent = mongoComponent,
  domainFormat   = VulnerabilityAge.mongoFormat,
  indexes        = Seq(
    IndexModel(Indexes.ascending("vulnerabilityId", "service"), IndexOptions().unique(true).background(true))
  )
) {

  override lazy val requiresTtlIndex = false

  private def toVulnerabilityAge(report: Report): Seq[VulnerabilityAge] =
    report
      .rows
      .map(row => VulnerabilityAge(serviceName = report.serviceName, firstScanned = report.generatedDate, vulnerabilityId = row.cves.flatMap(cve => cve.cveId).headOption.getOrElse(row.issueId)))
      .groupBy(_.vulnerabilityId)
      .map { case (_, group) => group.minBy(_.firstScanned) }
      .toSeq

  def insertNonExisting(report: Report): Future[Unit] =
    toVulnerabilityAge(report).foldLeftM[Future, Unit](()){ (_, va) =>
      collection
        .insertOne(va)
        .toFuture().map(_ => ())
        .recover { case DuplicateKey(_) => () }
    }

  def firstDetected(): Future[Map[String, Instant]] =
    collection
      .aggregate[BsonDocument](Seq(Aggregates.group("$vulnerabilityId", Accumulators.min("firstScanned", "$firstScanned"))))
      .toFuture()
      .map(_.map(bson => (bson.getString("_id").getValue -> Instant.ofEpochMilli(bson.getDateTime("firstScanned").getValue))))
      .map(_.toMap)
}
