/*
 * Copyright 2023 HM Revenue & Customs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package uk.gov.hmrc.vulnerabilities.persistence

import org.mongodb.scala.{ObservableFuture, MongoBulkWriteException}
import org.mongodb.scala.bson.BsonDocument
import org.mongodb.scala.model.{Aggregates, Accumulators, BulkWriteOptions, IndexModel, IndexOptions, Indexes}
import uk.gov.hmrc.mongo.MongoComponent
import uk.gov.hmrc.mongo.play.json.PlayMongoRepository
import uk.gov.hmrc.vulnerabilities.model.{VulnerabilityAge, Report}

import java.time.Instant
import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import org.mongodb.scala.model.InsertOneModel

@Singleton
class VulnerabilityAgeRepository @Inject()(
  mongoComponent: MongoComponent
)(using
  ec            : ExecutionContext
) extends PlayMongoRepository(
  collectionName = "vulnerabilityAge",
  mongoComponent = mongoComponent,
  domainFormat   = VulnerabilityAge.mongoFormat,
  indexes        = Seq(IndexModel(Indexes.ascending("vulnerabilityId", "service"), IndexOptions().unique(true).background(true)))
):

  override lazy val requiresTtlIndex = false

  private def toVulnerabilityAge(report: Report): Seq[VulnerabilityAge] =
    report
      .rows
      .map:
        row => VulnerabilityAge(
                  serviceName     = report.serviceName
                , firstScanned    = report.generatedDate
                , vulnerabilityId = row.cves.flatMap(cve => cve.cveId).headOption.getOrElse(row.issueId)
                )
      .groupBy(_.vulnerabilityId)
      .map:
        case (_, group) => group.minBy(_.firstScanned)
      .toSeq

  def insertNonExisting(report: Report): Future[Unit] =
    collection.bulkWrite(
      requests = toVulnerabilityAge(report).map(InsertOneModel.apply)
    , options  = BulkWriteOptions().ordered(false) // If false, then when a write fails, continue with the remaining writes
    ).toFuture()
     .recoverWith:
       case ex: MongoBulkWriteException if isDuplicateError(ex) => Future.unit
     .map(_ => ())

  private def isDuplicateError(e: MongoBulkWriteException): Boolean =
    import scala.jdk.CollectionConverters._
    e.getWriteErrors.asScala.map(_.getCode).contains(11000)

  def firstDetected(): Future[Map[String, Instant]] =
    collection
      .aggregate[BsonDocument](Seq(Aggregates.group("$vulnerabilityId", Accumulators.min("firstScanned", "$firstScanned"))))
      .toFuture()
      .map(_.map(bson => (bson.getString("_id").getValue -> Instant.ofEpochMilli(bson.getDateTime("firstScanned").getValue))))
      .map(_.toMap)
