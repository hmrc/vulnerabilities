/*
 * Copyright 2023 HM Revenue & Customs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package uk.gov.hmrc.vulnerabilities.persistence

import cats.implicits.catsSyntaxEq
import com.mongodb.client.model.Indexes
import org.mongodb.scala.bson.conversions.Bson
import org.mongodb.scala.bson.{BsonArray, BsonDocument}
import org.mongodb.scala.model.Accumulators.addToSet
import org.mongodb.scala.model.Aggregates._
import org.mongodb.scala.model.Projections._
import org.mongodb.scala.model.{Filters, IndexModel, IndexOptions, Sorts}
import uk.gov.hmrc.mongo.MongoComponent
import uk.gov.hmrc.mongo.play.json.{Codecs, PlayMongoRepository}
import uk.gov.hmrc.mongo.transaction.{TransactionConfiguration, Transactions}
import uk.gov.hmrc.vulnerabilities.config.AppConfig
import uk.gov.hmrc.vulnerabilities.model._

import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}

@Singleton
class VulnerabilitySummariesRepository @Inject()(
  override val mongoComponent: MongoComponent,
  appConfig: AppConfig
)(implicit
  ec            : ExecutionContext
) extends PlayMongoRepository(
  collectionName = "vulnerabilitySummaries",
  mongoComponent = mongoComponent,
  domainFormat   = VulnerabilitySummary.mongoFormat,
  indexes        = Seq(
                     IndexModel(Indexes.ascending("distinctVulnerability.id"),                      IndexOptions().unique(true).background(true)),
                     IndexModel(Indexes.ascending("distinctVulnerability.curationStatus"),          IndexOptions().background(true)),
                     IndexModel(Indexes.ascending("distinctVulnerability.vulnerableComponentName"), IndexOptions().background(true)),
                     IndexModel(Indexes.ascending("occurrences.service"),                           IndexOptions().background(true)),
                     IndexModel(Indexes.ascending("teams"),                                         IndexOptions().background(true))
                   ),
  extraCodecs    = Seq(
                    Codecs.playFormatCodec(VulnerabilityCount.mongoFormat),
                   )
) with Transactions {

  // unnecessary as data is cleaned down and re-inserted in `deleteOldAndInsertNewSummaries`
  override lazy val requiresTtlIndex = false

  def getVulnerabilitySummaries(): Future[Seq[VulnerabilitySummary]] =
    collection.find().toFuture()

  def putSummaries(summaries: Seq[VulnerabilitySummary]): Future[Int] =
    updateAllTx(summaries)

  def mergeNewSummaries(newSummaries: Seq[VulnerabilitySummary], allSvDeps: Seq[ServiceVersionDeployments]): Future[Int] =
    for {
      currentSummaries         <- getVulnerabilitySummaries()
      filteredCurrentSummaries =  filterOutEnvironmentsNoLongerDeployedTo(currentSummaries, allSvDeps)
      mergedSummaries          =  ensureOldVulnerabilitiesStillIncluded(filteredCurrentSummaries, newSummaries)
      inserted                 <- updateAllTx(mergedSummaries)
    } yield inserted

  private implicit val tc: TransactionConfiguration = TransactionConfiguration.strict
  private def updateAllTx(summaries: Seq[VulnerabilitySummary]) =
    withSessionAndTransaction { session =>
      for {
        _        <- collection.deleteMany(session, Filters.empty()).toFuture()
        inserted <- collection.insertMany(session, summaries).toFuture().map(_.getInsertedIds.size())
      } yield inserted
    }

  // Removes occurrences where they are no longer in ServiceVersionDeployments
  private [persistence] def filterOutEnvironmentsNoLongerDeployedTo(currentSummaries: Seq[VulnerabilitySummary], allSvDeps: Seq[ServiceVersionDeployments]): Seq[VulnerabilitySummary] = {
    currentSummaries
      .map(vs => vs.copy(occurrences = vs.occurrences
        .map(occ => occ.copy(envs = occ.envs.filter(env => allSvDeps.exists(svd => svd.serviceName === occ.service && svd.version === occ.serviceVersion && svd.environments.contains(env)))))
        .filter(occ => occ.envs.nonEmpty)))
      .filter(vs => vs.occurrences.nonEmpty)
  }

  // If a vulnerability only exists in filteredCurrentSummaries add it back to newSummaries. ditto for environments
  private [persistence] def ensureOldVulnerabilitiesStillIncluded(filteredCurrentSummaries: Seq[VulnerabilitySummary], newSummaries: Seq[VulnerabilitySummary]): Seq[VulnerabilitySummary] = {
    val summariesNotInNew = filteredCurrentSummaries.filterNot(cur => newSummaries.exists(newS => newS.distinctVulnerability.id === cur.distinctVulnerability.id))

    val newSummariesWithEnvironmentsNotInNew = newSummaries.map(ns =>
      filteredCurrentSummaries.find(summary => summary.distinctVulnerability.id === ns.distinctVulnerability.id) match {
        case Some(cs) => ns.copy(occurrences = ns.occurrences.map(occ => cs.occurrences.find(x => x.service == occ.service && x.serviceVersion === occ.serviceVersion && x.envs =!= occ.envs) match {
          case Some(value) => value.copy(envs = occ.envs.appendedAll(value.envs).distinct)
          case None => occ
        }))
        case None => ns
      }
    )

    summariesNotInNew ++ newSummariesWithEnvironmentsNotInNew
  }

  def distinctVulnerabilitiesSummary(
    id             : Option[String],
    curationStatus : Option[String],
    service        : Option[String],
    version        : Option[Version],
    team           : Option[String],
    component      : Option[String]
  ): Future[Seq[VulnerabilitySummary]] = {
    val Quoted = """^\"(.*)\"$""".r

    //Applying these filters together inside an elem match will ensure that we only return documents with an occurrence
    //containing both the service, serviceVersion AND the team (if both are specified). Without the elemMatch, Mongo will do an OR.
    val occurrenceFilters: Seq[Bson] = Seq(
      service.map {
        case Quoted(s) => Filters.equal("service", s.toLowerCase())
        case s         => Filters.regex("service", s.toLowerCase())
      },
      version.map(v => Filters.equal("serviceVersion",  v.original)),
      team.map(t => Filters.equal("teams", t))
    ).flatten

    val dvFilters: Seq[Bson] = Seq(
      id.map            (i => Filters.regex("distinctVulnerability.id", i.toUpperCase())),
      curationStatus.map(r => Filters.equal("distinctVulnerability.curationStatus", r)),
      team.map          (t => Filters.equal("teams", t)),
      component.map     (c => Filters.regex("distinctVulnerability.vulnerableComponentName", c.toLowerCase())),
      if (occurrenceFilters.isEmpty) None else Some(Filters.elemMatch("occurrences", Filters.and(occurrenceFilters: _*)))
    ).flatten

    val pipeline: Seq[Bson] = Seq(
      // Apply all filters at the top level
      if (dvFilters.isEmpty) None else Some(`match`(Filters.and(dvFilters: _*))) ,
      // Remove elements from occurences array that don't match the team filter
      service.map(service => project(BsonDocument(
          "distinctVulnerability" -> "$distinctVulnerability",
          "teams"                 -> "$teams",
          "occurrences"           ->
            BsonDocument("$filter" -> BsonDocument(
              "input" -> "$occurrences",
              "as"    -> "o",
              "cond"  -> {
                service match {
                  case Quoted(s) => BsonDocument("$eq" -> BsonArray("$$o.service", s))
                  case s         => BsonDocument("$regexMatch" -> BsonDocument("input" -> "$$o.service", "regex" -> s))
                }
              }
            )),
          "generatedDate"         -> "$generatedDate"
        ))
      ),
      // Remove elements from occurences array that don't match the service filter
      version.map(version => project(BsonDocument(
          "distinctVulnerability" -> "$distinctVulnerability",
          "teams"                 -> "$teams",
          "occurrences"           ->
            BsonDocument("$filter" -> BsonDocument(
              "input" -> "$occurrences",
              "as"    -> "o",
              "cond"  -> BsonDocument("$eq" -> BsonArray("$$o.serviceVersion", version.original))
            )),
          "generatedDate"         -> "$generatedDate"
        ))
      ),
      // Remove elements from occurences that match exclusion regex
      Some(project(BsonDocument(
        "distinctVulnerability" -> "$distinctVulnerability",
        "teams" -> "$teams",
        "occurrences" ->
          BsonDocument("$filter" -> BsonDocument(
            "input" -> "$occurrences",
            "as" -> "o",
            "cond" -> BsonDocument("$regexMatch" -> BsonDocument("input" -> "$$o.componentPathInSlug", "regex" -> appConfig.exclusionRegex))
          )),
        "generatedDate" -> "$generatedDate"
      ))),
      // Sort
      Some(sort(
        Sorts.orderBy(Sorts.descending("distinctVulnerability.score"), Sorts.ascending("distinctVulnerability.id"))
      )),
      // Remove elements from occurences array that don't match the service filter
      team.map(team => project(BsonDocument(
        "distinctVulnerability" -> "$distinctVulnerability",
        "teams"                 -> "$teams",
        "occurrences"           ->
          BsonDocument("$filter" -> BsonDocument(
            "input" -> "$occurrences",
            "as"    -> "o",
            "cond"  -> BsonDocument("$in" -> BsonArray(team, "$$o.teams"))
          )),
        "generatedDate"         -> "$generatedDate"
      ))),
      // Sort
      Some(sort(
        Sorts.orderBy(Sorts.descending("distinctVulnerability.score"), Sorts.ascending("distinctVulnerability.id"))
      )),
      // Filter only if occurrences exist
      Some(`match`(BsonDocument("occurrences.0" -> BsonDocument("$exists" -> true))))
    ).flatten

    collection.aggregate(pipeline).toFuture()
  }


  def vulnerabilitiesCount(service: Option[String], team: Option[String], environment: Option[Environment]): Future[Seq[VulnerabilityCount]] = {
    val Quoted = """^\"(.*)\"$""".r

    val optionalFilters = Seq(
      service.map {
        case Quoted(s) => Filters.equal("occurrences.service", s.toLowerCase())
        case s         => Filters.regex("occurrences.service", s.toLowerCase())
      },
      team       .map(t => Filters.equal("occurrences.teams", t)),
      environment.map(e => Filters.equal("occurrences.envs" , e.asString))
    ).flatten

    val pipeline = Seq(
      project(
        fields(
          include(
            "occurrences",
            "distinctVulnerability.curationStatus",
            "distinctVulnerability.id"
          )
        )
      ),
      unwind("$occurrences"),
      project(
        fields(
          include(
            "distinctVulnerability.curationStatus",
            "distinctVulnerability.id",
            "occurrences.service",
            "occurrences.envs",
            "occurrences.teams",
            "occurrences.componentPathInSlug"
          )
        )
      ),
      unwind("$occurrences.envs"),
      if (optionalFilters.isEmpty) `match`(Filters.empty()) else `match`(Filters.and(optionalFilters: _*)),
      `match`(Filters.regex("occurrences.componentPathInSlug", appConfig.exclusionRegex)),
      group(
        BsonDocument(
          "environment"          -> "$occurrences.envs",
          "service"              -> "$occurrences.service",
          "curationStatus"       -> "$distinctVulnerability.curationStatus"
        ),
        addToSet("count", "$distinctVulnerability.id")
      ),
      project(
        fields(
          computed("service", "$_id.service"),
          computed("environment", "$_id.environment"),
          computed("curationStatus", "$_id.curationStatus"),
          BsonDocument("count" -> BsonDocument("$size" -> s"$$count")),
          excludeId()
        )
      )
    )

    collection.aggregate[VulnerabilityCount](pipeline).toFuture()
  }
}
