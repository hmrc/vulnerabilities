/*
 * Copyright 2023 HM Revenue & Customs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package uk.gov.hmrc.vulnerabilities.persistence

import com.mongodb.client.model.Indexes
import org.mongodb.scala.bson.conversions.Bson
import org.mongodb.scala.bson.{BsonArray, BsonDocument}
import org.mongodb.scala.model.Accumulators.addToSet
import org.mongodb.scala.model.Aggregates._
import org.mongodb.scala.model.Projections._
import org.mongodb.scala.model.{Filters, IndexModel, IndexOptions, Sorts}
import play.api.Logger
import uk.gov.hmrc.mongo.MongoComponent
import uk.gov.hmrc.mongo.play.json.{Codecs, PlayMongoRepository}
import uk.gov.hmrc.mongo.transaction.{TransactionConfiguration, Transactions}
import uk.gov.hmrc.vulnerabilities.model.{Environment, VulnerabilityCount, VulnerabilitySummary}

import java.time.Instant
import java.time.temporal.ChronoUnit
import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}

@Singleton
class VulnerabilitySummariesRepository @Inject()(
                                          override val mongoComponent: MongoComponent
                                         )(implicit ec: ExecutionContext
                                         ) extends PlayMongoRepository(
  collectionName = "vulnerabilitySummaries",
  mongoComponent = mongoComponent,
  domainFormat   = VulnerabilitySummary.mongoFormat,
  indexes        = Seq(
    IndexModel(Indexes.ascending("occurrences.service"), IndexOptions().name("occurrences.service").background(true)),
    IndexModel(Indexes.ascending("distinctVulnerability.id"), IndexOptions().name("distinctVulnerability.id").background(true)),
    IndexModel(Indexes.ascending("teams"), IndexOptions().name("teams").background(true)),
    IndexModel(Indexes.ascending("distinctVulnerability.curationStatus"), IndexOptions().name("distinctVulnerability.curationStatus").background(true)),
  ),
  extraCodecs = Seq(
    Codecs.playFormatCodec(VulnerabilityCount.mongoFormat),
  )
) with Transactions {

  private def defaultDate = Instant.now().minus(8, ChronoUnit.DAYS)
  private val logger = Logger(this.getClass)

  def getMostRecent(): Future[Instant] =
    collection
      .find()
      .sort(Sorts.descending("generatedDate"))
      .headOption()
      .map(_.map(_.generatedDate).getOrElse(defaultDate))

  private implicit val tc = TransactionConfiguration.strict

  def deleteOldAndInsertNewSummaries(summaries: Seq[VulnerabilitySummary]): Future[Int] =
    withSessionAndTransaction(session =>
      for {
        _        <- collection.deleteMany(session, Filters.empty()).toFuture()
        inserted <- collection.insertMany(session, summaries).toFuture().map(_.getInsertedIds.size())
      } yield inserted
    )

  def distinctVulnerabilitiesSummary(
    id             : Option[String],
    curationStatus : Option[String],
    service        : Option[String],
    team           : Option[String],
    component      : Option[String]
  ): Future[Seq[VulnerabilitySummary]] = {
    val Quoted = """^\"(.*)\"$""".r

    val allFilters = Seq(
      id.map(i => Filters.regex("distinctVulnerability.id", i.toUpperCase())),
      curationStatus.map(r => Filters.equal("distinctVulnerability.curationStatus", r)),
      team.map(t => Filters.equal("teams", t)),
      component.map(c => Filters.regex("distinctVulnerability.vulnerableComponentName", c.toLowerCase())),
      service.map {
        case Quoted(s) => Filters.equal("occurrences.service", s.toLowerCase())
        case s => Filters.regex("occurrences.service", s.toLowerCase())
      }
    ).flatten

    val pipeline: Seq[Bson] = Seq(
      if(allFilters.isEmpty) None else Some(`match`(Filters.and(allFilters: _*))) ,
      service.map(service => project(BsonDocument(
          "distinctVulnerability" -> "$distinctVulnerability",
          "teams"                 -> "$teams",
          "occurrences"           ->
            BsonDocument("$filter" -> BsonDocument(
              "input" -> "$occurrences",
              "as"    -> "o",
              "cond"  -> {
                service match {
                  case Quoted(s) => BsonDocument("$eq" -> BsonArray("$$o.service", s))
                  case s => BsonDocument("$regexMatch" -> BsonDocument("input" -> "$$o.service", "regex" -> s))
                }
              }
            )),
          "generatedDate"         -> "$generatedDate"

        ))
      ),
      team.map(team => project(BsonDocument(
        "distinctVulnerability" -> "$distinctVulnerability",
        "teams"                 -> "$teams",
        "occurrences"           ->
          BsonDocument("$filter" -> BsonDocument(
            "input" -> "$occurrences",
            "as"    -> "o",
            "cond"  -> BsonDocument("$in" -> BsonArray(team, "$$o.teams"))
          )),
        "generatedDate"         -> "$generatedDate"
      ))),
      Some(sort(
        Sorts.orderBy(Sorts.descending("distinctVulnerability.score"), Sorts.ascending("distinctVulnerability.id"))
      ))
    ).flatten

    collection.aggregate(pipeline).toFuture()
  }


  def vulnerabilitiesCount(service: Option[String], team: Option[String], environment: Option[Environment]): Future[Seq[VulnerabilityCount]] = {
    val Quoted = """^\"(.*)\"$""".r

    val allFilters = Seq(
      service.map {
        case Quoted(s) => Filters.equal("occurrences.service", s.toLowerCase())
        case s         => Filters.regex("occurrences.service", s.toLowerCase())
      },
             team.map(t => Filters.equal("occurrences.teams", t)),
      environment.map(e => Filters.equal("occurrences.envs", e.asString))
    ).flatten

    val pipeline = Seq(
      project(
        fields(
          include(
            "occurrences",
            "distinctVulnerability.curationStatus",
            "distinctVulnerability.id"
          )
        )
      ),
      unwind("$occurrences"),
      project(
        fields(
          include(
            "distinctVulnerability.curationStatus",
            "distinctVulnerability.id",
            "occurrences.service",
            "occurrences.envs",
            "occurrences.teams"
          )
        )
      ),
      unwind("$occurrences.envs"),
      if(allFilters.isEmpty) `match`(Filters.empty()) else `match`(Filters.and(allFilters: _*)),
      group(
        BsonDocument(
          "environment"     -> "$occurrences.envs",
          "service"         -> "$occurrences.service",
          "curationStatus"  -> "$distinctVulnerability.curationStatus"
        ),
        addToSet("count", "$distinctVulnerability.id")
      ),
      project(
        fields(
          computed("service", "$_id.service"),
          computed("environment", "$_id.environment"),
          computed("curationStatus", "$_id.curationStatus"),
          BsonDocument("count" -> BsonDocument("$size" -> "$count")),
          excludeId()
        )
      )
    )
    collection.aggregate[VulnerabilityCount](pipeline).toFuture()
  }
}