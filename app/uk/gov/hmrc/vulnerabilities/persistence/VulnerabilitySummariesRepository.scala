/*
 * Copyright 2023 HM Revenue & Customs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package uk.gov.hmrc.vulnerabilities.persistence

import com.mongodb.client.model.Indexes
import org.mongodb.scala.bson.conversions.Bson
import org.mongodb.scala.bson.{BsonArray, BsonDocument}
import org.mongodb.scala.model.Accumulators.addToSet
import org.mongodb.scala.model.Aggregates._
import org.mongodb.scala.model.Projections._
import org.mongodb.scala.model.{Filters, IndexModel, IndexOptions, Sorts}
import uk.gov.hmrc.mongo.MongoComponent
import uk.gov.hmrc.mongo.play.json.{Codecs, PlayMongoRepository}
import uk.gov.hmrc.mongo.transaction.{TransactionConfiguration, Transactions}
import uk.gov.hmrc.vulnerabilities.model.{Environment, Version, VulnerabilityCount, VulnerabilitySummary}

import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}

@Singleton
class VulnerabilitySummariesRepository @Inject()(
  override val mongoComponent: MongoComponent
)(implicit
  ec            : ExecutionContext
) extends PlayMongoRepository(
  collectionName = "vulnerabilitySummaries",
  mongoComponent = mongoComponent,
  domainFormat   = VulnerabilitySummary.mongoFormat,
  indexes        = Seq(
    IndexModel(Indexes.ascending("occurrences.service"), IndexOptions().name("occurrences.service").background(true)),
    IndexModel(Indexes.ascending("distinctVulnerability.id"), IndexOptions().name("distinctVulnerability.id").background(true)),
    IndexModel(Indexes.ascending("teams"), IndexOptions().name("teams").background(true)),
    IndexModel(Indexes.ascending("distinctVulnerability.curationStatus"), IndexOptions().name("distinctVulnerability.curationStatus").background(true)),
    IndexModel(Indexes.ascending("distinctVulnerability.vulnerableComponentName"), IndexOptions().name("distinctVulnerability.vulnerableComponentName").background(true)),

  ),
  extraCodecs = Seq(
    Codecs.playFormatCodec(VulnerabilityCount.mongoFormat),
  )
) with Transactions {

  // unnecessary as data is cleaned down and re-inserted in `deleteOldAndInsertNewSummaries`
  override lazy val requiresTtlIndex = false

  def getVulnerabilitySummaries(): Future[Seq[VulnerabilitySummary]] =
    collection.find().toFuture()

  private implicit val tc = TransactionConfiguration.strict

  def deleteOldAndInsertNewSummaries(summaries: Seq[VulnerabilitySummary]): Future[Int] =
    withSessionAndTransaction(session =>
      for {
        _        <- collection.deleteMany(session, Filters.empty()).toFuture()
        inserted <- collection.insertMany(session, summaries).toFuture().map(_.getInsertedIds.size())
      } yield inserted
    )

  def distinctVulnerabilitiesSummary(
    id             : Option[String],
    curationStatus : Option[String],
    service        : Option[String],
    version        : Option[Version],
    team           : Option[String],
    component      : Option[String]
  ): Future[Seq[VulnerabilitySummary]] = {
    val Quoted = """^\"(.*)\"$""".r

    //Applying these filters together inside an elem match will ensure that we only return documents with an occurrence
    //containing both the service, serviceVersion AND the team (if both are specified). Without the elemMatch, Mongo will do an OR.
    val occurrenceFilters: Seq[Bson] = Seq(
      service.map {
        case Quoted(s) => Filters.equal("service", s.toLowerCase())
        case s         => Filters.regex("service", s.toLowerCase())
      },
      version.map(v => Filters.equal("serviceVersion",  v.original)),
      team.map(t => Filters.equal("teams", t)),
    ).flatten

    val dvFilters: Seq[Bson] = Seq(
      id.map            (i => Filters.regex("distinctVulnerability.id", i.toUpperCase())),
      curationStatus.map(r => Filters.equal("distinctVulnerability.curationStatus", r)),
      team.map          (t => Filters.equal("teams", t)),
      component.map     (c => Filters.regex("distinctVulnerability.vulnerableComponentName", c.toLowerCase())),
      if (occurrenceFilters.isEmpty) None else Some(Filters.elemMatch("occurrences", Filters.and(occurrenceFilters: _*)))
    ).flatten

    val pipeline: Seq[Bson] = Seq(
      //1. Apply all filters at the top level
      if (dvFilters.isEmpty) None else Some(`match`(Filters.and(dvFilters: _*))) ,
      //2. Remove elements from occurences array that don't match the team filter
      service.map(service => project(BsonDocument(
          "distinctVulnerability" -> "$distinctVulnerability",
          "teams"                 -> "$teams",
          "occurrences"           ->
            BsonDocument("$filter" -> BsonDocument(
              "input" -> "$occurrences",
              "as"    -> "o",
              "cond"  -> {
                service match {
                  case Quoted(s) => BsonDocument("$eq" -> BsonArray("$$o.service", s))
                  case s         => BsonDocument("$regexMatch" -> BsonDocument("input" -> "$$o.service", "regex" -> s))
                }
              }
            )),
          "generatedDate"         -> "$generatedDate"
        ))
      ),
      //3. Remove elements from occurences array that don't match the service filter
      version.map(version => project(BsonDocument(
          "distinctVulnerability" -> "$distinctVulnerability",
          "teams"                 -> "$teams",
          "occurrences"           ->
            BsonDocument("$filter" -> BsonDocument(
              "input" -> "$occurrences",
              "as"    -> "o",
              "cond"  -> BsonDocument("$eq" -> BsonArray("$$o.serviceVersion", version.original))
            )),
          "generatedDate"         -> "$generatedDate"
        ))
      ),
      //4. Sort
      Some(sort(
        Sorts.orderBy(Sorts.descending("distinctVulnerability.score"), Sorts.ascending("distinctVulnerability.id"))
      )),
      //4. Remove elements from occurences array that don't match the service filter
      team.map(team => project(BsonDocument(
        "distinctVulnerability" -> "$distinctVulnerability",
        "teams"                 -> "$teams",
        "occurrences"           ->
          BsonDocument("$filter" -> BsonDocument(
            "input" -> "$occurrences",
            "as"    -> "o",
            "cond"  -> BsonDocument("$in" -> BsonArray(team, "$$o.teams"))
          )),
        "generatedDate"         -> "$generatedDate"
      ))),
      //4. Sort
      Some(sort(
        Sorts.orderBy(Sorts.descending("distinctVulnerability.score"), Sorts.ascending("distinctVulnerability.id"))
      ))
    ).flatten

    collection.aggregate(pipeline).toFuture()
  }


  def vulnerabilitiesCount(service: Option[String], team: Option[String], environment: Option[Environment]): Future[Seq[VulnerabilityCount]] = {
    val Quoted = """^\"(.*)\"$""".r

    val allFilters = Seq(
      service.map {
        case Quoted(s) => Filters.equal("occurrences.service", s.toLowerCase())
        case s         => Filters.regex("occurrences.service", s.toLowerCase())
      },
      team       .map(t => Filters.equal("occurrences.teams", t)),
      environment.map(e => Filters.equal("occurrences.envs" , e.asString))
    ).flatten

    val pipeline = Seq(
      project(
        fields(
          include(
            "occurrences",
            "distinctVulnerability.curationStatus",
            "distinctVulnerability.id"
          )
        )
      ),
      unwind("$occurrences"),
      project(
        fields(
          include(
            "distinctVulnerability.curationStatus",
            "distinctVulnerability.id",
            "occurrences.service",
            "occurrences.envs",
            "occurrences.teams"
          )
        )
      ),
      unwind("$occurrences.envs"),
      if (allFilters.isEmpty) `match`(Filters.empty()) else `match`(Filters.and(allFilters: _*)),
      group(
        BsonDocument(
          "environment"     -> "$occurrences.envs",
          "service"         -> "$occurrences.service",
          "curationStatus"  -> "$distinctVulnerability.curationStatus"
        ),
        addToSet("count", "$distinctVulnerability.id")
      ),
      project(
        fields(
          computed("service", "$_id.service"),
          computed("environment", "$_id.environment"),
          computed("curationStatus", "$_id.curationStatus"),
          BsonDocument("count" -> BsonDocument("$size" -> s"$$count")),
          excludeId()
        )
      )
    )
    collection.aggregate[VulnerabilityCount](pipeline).toFuture()
  }
}
