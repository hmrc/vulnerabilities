/*
 * Copyright 2022 HM Revenue & Customs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package uk.gov.hmrc.vulnerabilities.persistence

import com.mongodb.client.model.Indexes
import org.mongodb.scala.bson.conversions.Bson
import org.mongodb.scala.bson.{BsonArray, BsonDocument, conversions}
import org.mongodb.scala.model.{Filters, IndexModel, IndexOptions, Sorts}
import uk.gov.hmrc.mongo.MongoComponent
import uk.gov.hmrc.mongo.play.json.PlayMongoRepository
import org.mongodb.scala.model.Aggregates._
import uk.gov.hmrc.vulnerabilities.model.VulnerabilitySummary

import java.time.{Instant, LocalDateTime, ZoneOffset}
import java.time.temporal.ChronoUnit
import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}

@Singleton
class VulnerabilitySummariesRepository @Inject()(
                                           mongoComponent: MongoComponent
                                         )(implicit ec: ExecutionContext
                                         ) extends PlayMongoRepository(
  collectionName = "vulnerabilitySummaries",
  mongoComponent = mongoComponent,
  domainFormat   = VulnerabilitySummary.mongoFormat,
  indexes        = Seq(
    IndexModel(Indexes.ascending("occurrences.service"), IndexOptions().name("occurrences.service").background(true)),
    IndexModel(Indexes.ascending("distinctVulnerability.id"), IndexOptions().name("distinctVulnerability.id").background(true)),
    IndexModel(Indexes.ascending("teams"), IndexOptions().name("teams").background(true)),
    IndexModel(Indexes.ascending("distinctVulnerability.curationStatus"), IndexOptions().name("distinctVulnerability.curationStatus").background(true)),
  ),
) {

  private def defaultDate = LocalDateTime.now().toInstant(ZoneOffset.UTC).minus(8, ChronoUnit.DAYS)

  def getMostRecent: Future[Instant] =
    collection
      .find()
      .sort(Sorts.descending("generatedDate"))
      .headOption()
      .map(_.map(_.generatedDate).getOrElse(defaultDate))

  def deleteAllSummaries: Future[Int] =
    collection
      .deleteMany(Filters.empty())
      .toFuture()
      .map(_.getDeletedCount.toInt)

  def insertSummaries(summaries: Seq[VulnerabilitySummary]): Future[Int] =
    collection
      .insertMany(summaries)
      .toFuture()
      .map(_.getInsertedIds.size())

  def distinctVulnerabilitiesSummary(id: Option[String], curationStatus: Option[String], service: Option[String], team: Option[String]): Future[Seq[VulnerabilitySummary]] = {
    val Quoted = """^\"(.*)\"$""".r

    val allFilters = Seq(
                  id.map(i => Filters.regex("distinctVulnerability.id", i.toUpperCase())),
      curationStatus.map(r => Filters.equal("distinctVulnerability.curationStatus", r)),
                team.map(t => Filters.equal("teams", t)),
            service.map {
              case Quoted(s) => Filters.equal("occurrences.service", s.toLowerCase())
              case s         => Filters.regex("occurrences.service", s.toLowerCase())
            }
          ).flatten

    val pipeline: Seq[Bson] = Seq(
      if(allFilters.isEmpty) None else Some(`match`(Filters.and(allFilters: _*))) ,
      service.map(service => project(BsonDocument(
          "distinctVulnerability" -> "$distinctVulnerability",
          "teams"                 -> "$teams",
          "occurrences"           ->
            BsonDocument("$filter" -> BsonDocument(
              "input" -> "$occurrences",
              "as"    -> "o",
              "cond"  -> {
                service match {
                  case Quoted(s) => BsonDocument("$eq" -> BsonArray("$$o.service", s))
                  case s => BsonDocument("$regexMatch" -> BsonDocument("input" -> "$$o.service", "regex" -> s))
                }
              }
            )),
          "generatedDate"         -> "$generatedDate"

        ))
      ),
      team.map(team => project(BsonDocument(
        "distinctVulnerability" -> "$distinctVulnerability",
        "teams"                 -> "$teams",
        "occurrences"           ->
          BsonDocument("$filter" -> BsonDocument(
            "input" -> "$occurrences",
            "as"    -> "o",
            "cond"  -> BsonDocument("$in" -> BsonArray(team, "$$o.teams"))
          )),
        "generatedDate"         -> "$generatedDate"
      ))),
      Some(sort(
        Sorts.orderBy(Sorts.descending("distinctVulnerability.score"), Sorts.ascending("distinctVulnerability.id"))
      ))
    ).flatten

    collection.aggregate(pipeline).toFuture()
  }
}