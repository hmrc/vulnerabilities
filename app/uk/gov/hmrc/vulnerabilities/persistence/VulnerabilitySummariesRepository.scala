/*
 * Copyright 2022 HM Revenue & Customs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package uk.gov.hmrc.vulnerabilities.persistence

import com.mongodb.client.model.Indexes
import org.mongodb.scala.bson.{BsonArray, BsonDocument, conversions}
import org.mongodb.scala.model.{Filters, IndexModel, IndexOptions, Sorts}
import uk.gov.hmrc.mongo.MongoComponent
import uk.gov.hmrc.mongo.play.json.PlayMongoRepository
import org.mongodb.scala.model.Aggregates._
import uk.gov.hmrc.vulnerabilities.model.VulnerabilitySummary

import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}

@Singleton
class VulnerabilitySummariesRepository @Inject()(
                                           mongoComponent: MongoComponent
                                         )(implicit ec: ExecutionContext
                                         ) extends PlayMongoRepository(
  collectionName = "vulnerabilitySummaries",
  mongoComponent = mongoComponent,
  domainFormat   = VulnerabilitySummary.mongoFormat,
  indexes        = Seq(
    IndexModel(Indexes.ascending("occurrences.service"), IndexOptions().name("occurrences.service").background(true)),
    IndexModel(Indexes.ascending("distinctVulnerability.id"), IndexOptions().name("distinctVulnerability.id").background(true)),
    IndexModel(Indexes.ascending("teams"), IndexOptions().name("teams").background(true)),
    IndexModel(Indexes.ascending("distinctVulnerability.curationStatus"), IndexOptions().name("distinctVulnerability.curationStatus").background(true)),
  ),
) {
  def distinctVulnerabilitiesSummary(id: Option[String], curationStatus: Option[String], service: Option[String], team: Option[String]): Future[Seq[VulnerabilitySummary]] = {
    val Quoted = """^\"(.*)\"$""".r

    val allFilters = Seq(
                  id.map(i => Filters.regex("distinctVulnerability.id", i.toUpperCase())),
      curationStatus.map(r => Filters.equal("distinctVulnerability.curationStatus", r)),
                team.map(t => Filters.equal("teams", t)),
            service.map {
              case Quoted(s) => Filters.equal("occurrences.service", s.toLowerCase())
              case s         => Filters.regex("occurrences.service", s.toLowerCase())
            }
          ).flatten

    def removeUnmatchedServices(service: String): conversions.Bson = {
      service match {
        case Quoted(s) => project(BsonDocument(
          "distinctVulnerability" -> "$distinctVulnerability",
          "teams"                 -> "$teams",
          "occurrences"           ->
            BsonDocument("$filter" -> BsonDocument(
              "input" -> "$occurrences",
              "as"    -> "o",
              "cond"  -> BsonDocument("$eq" -> BsonArray("$$o.service", s))
            )
            )
        ))
        case s => project(BsonDocument(
          "distinctVulnerability" -> "$distinctVulnerability",
          "teams"                 -> "$teams",
          "occurrences"           ->
            BsonDocument("$filter" -> BsonDocument(
              "input" -> "$occurrences",
              "as"    -> "o",
              "cond"  -> BsonDocument("$regexMatch" -> BsonDocument("input" -> "$$o.service", "regex" -> s))
            )
            )
        ))
      }
    }

    def removeUnmatchedTeams(team: String): conversions.Bson =
      project(BsonDocument(
        "distinctVulnerability" -> "$distinctVulnerability",
        "teams"                 -> "$teams",
        "occurrences"           ->
          BsonDocument("$filter" -> BsonDocument(
            "input" -> "$occurrences",
            "as"    -> "o",
            "cond"  -> BsonDocument("$in" -> BsonArray(team, "$$o.teams"))
          )
          )
      ))

    val pipelineSort = Seq(
      sort(
        Sorts.orderBy(Sorts.descending("distinctVulnerability.score"), Sorts.ascending("distinctVulnerability.id"))
      )
    )

    //Use pattern matching to execute either a find, or an aggregate pipeline - depending on the query params passed in.
    //Pipeline required for service/team params, as need to filter out the occurrences that don't match
    (team, service, allFilters) match {
      case (_, _, Nil)              => collection.find().sort(
        Sorts.orderBy(Sorts.descending("distinctVulnerability.score"), Sorts.ascending("distinctVulnerability.id"))).toFuture()
      case (None, None, more)          => collection.find(Filters.and(more: _*)).sort(
        Sorts.orderBy(Sorts.descending("distinctVulnerability.score"), Sorts.ascending("distinctVulnerability.id"))).toFuture()
      case (None      , Some(service), more) => collection.aggregate(`match`(Filters.and(more: _*)) +: removeUnmatchedServices(service) +: pipelineSort).toFuture()
      case (Some(team), None         , more) => collection.aggregate(`match`(Filters.and(more: _*)) +: removeUnmatchedTeams(team)       +: pipelineSort).toFuture()
      case (Some(team), Some(service), more) => collection.aggregate(`match`(Filters.and(more: _*)) +: removeUnmatchedServices(service) +: removeUnmatchedTeams(team) +: pipelineSort).toFuture()
    }
  }
}